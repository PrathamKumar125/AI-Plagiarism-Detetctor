# AI-Plagiarism-Detector
<br>

## Docker image: 
```bash
docker pull prathamkumars125/aiplagiarsmdetector:v1.0
```
<br>

## Deployed Link: https://ai-plagiarism-detetctor-pkkdcztehsm8nbatveqddf.streamlit.app/
![image](https://github.com/PrathamKumar125/AI-Plagiarism-Detetctor/assets/115283906/5967cb72-f843-431a-a609-c06be40e3147)

<br>

# Dockerize an Application & push it to Dockerhub

## Prerequisites

Ensure the following:

1. Docker Desktop for Windows: [Install Docker Desktop](https://docs.docker.com/desktop/install/)
2. An application to dockerize

## Steps
### Step 1: Dockerfile Creation: Create a `Dockerfile` in the root directory of your application. The `Dockerfile` is a text file that contains instructions for building the Docker image.

### Step 2: Build the Docker Image: Open a command prompt or PowerShell window and navigate to the directory containing your `Dockerfile`. Run the following command to build the Docker image:

```bash
docker build -t your-image-name .
```

Replace `your-image-name` with the desired Docker image name.

### Step 3: Verify the Docker Image: Once the Docker build process completes, you can verify that the image was created successfully by running the following command:

```bash
docker images
```

This command will display a list of Docker images on your system, including the one you just built.

### Step 4: Run the Docker Container: To run a container based on the Docker image you just created, use the following command:

```bash
docker run -d -p 8080:80 your-image-name
```

Replace `your-image-name` with the Docker image name.

### Step 6: Access Your Application: Once the container is running, you can access your application by navigating to `http://localhost:8080` in your web browser (assuming your application is a web application listening on port 80).

### Step 7: Log in to Docker Hub: [Create Docker Hub Account](https://hub.docker.com/signup) then log in to your Docker Hub account from the command line. Open a terminal or command prompt and run the following command:

```bash
docker login
```

Once logged in, you will receive a message indicating that you are authenticated.

### Step 8: Tag Your Docker Image: Before pushing, tag the Docker image with Docker Hub username and the repository name. Run the following command to tag your Docker image:

```bash
docker tag your-image-name your-dockerhub-username/repository-name:tag
```

Replace `your-image-name` with the name of the Docker image you want to push, `your-dockerhub-username` with your Docker Hub username, `repository-name` with the name of the repository on Docker Hub where you want to push the image, and `tag` with a tag for the image (e.g., `latest`).

### Step 9: Push Your Docker Image: Once you've tagged, push it to Docker Hub using the following command:

```bash
docker push your-dockerhub-username/repository-name:tag
```

Replace `your-dockerhub-username`, `repository-name`, and `tag` with the values you used when tagging the image.

### Step 10: Verify the Image on Docker Hub: After pushing the Docker image, you can verify that it was successfully uploaded to Docker Hub by visiting the [Docker Hub website](https://hub.docker.com/) and navigating to your repository. You should see your image listed there with the tag you specified.

## Docker image: https://hub.docker.com/repository/docker/prathamkumars125/aiplagiarsmdetector/general
<br>
<br>

# Deploying the Application Using Argo CD and Kubernetes

## Prerequisites

Ensure the following:

1. Kubernetes cluster running (using KIND)
2. Argo CD installed and running in your Kubernetes cluster
3. An application hosted in a Git repository

## Steps

### Step 1: Define Application Manifests: Argo CD works based on Kubernetes manifests stored in Git repositories. Define your application manifests (e.g., Deployment, Service) and store them in a Git repository. Ensure that your manifests are properly configured to deploy your application to Kubernetes.

### Step 2: Add Git Repository to Argo CD

Open the Argo CD web interface by navigating to `http://localhost:8080` (assuming Argo CD is running locally). 
Log in using the following credentials:

- **Username**: admin
- **Password**: Retrieve the password by running the following command:

```bash
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
```

Copy the password generated by the command and paste it into the password field on the login page.

After Logged in,
1. Click on the `Settings` tab on the left sidebar.
2. Under `Repositories`, click on `CONNECT REPO USING HTTPS`.
3. Enter the URL of your Git repository and provide any credentials if required.
4. Click `CONNECT`.

Argo CD will now sync with the Git repository and retrieve the application manifests.

### Step 3: Create Argo CD Application

Once the Git repository is connected, create an application in Argo CD to deploy your manifests.

1. Click on the `Applications` tab on the left sidebar.
2. Click on `NEW APPLICATION`.
3. Fill in the application details:
   - **Name**: Name of your application
   - **Project**: Choose a project or create a new one
   - **Sync Policy**: Choose the sync policy for your application (e.g., manual, automatic)
   - **Source**: Choose the repository and provide the path to the directory containing your manifests
   - **Destination**: create namespace `kubectl create namespace yournamespace` , verify it `kubectl get ns` . After successful creation, specify that namespace where your application will be deployed
4. Click `CREATE`.

Argo CD will start syncing with the Git repository and deploy your application to the specified namespace.

### Step 4: Monitor Deployment: Monitor the deployment progress and status of the application in the Argo CD web interface. Once the deployment is complete, you should see the status of your application as `Healthy`.

### Step 5: Access Your Application

Once the application is deployed, you can access it using Port Forwarding

```bash
kubectl port-forward svc/your-service-name -n your-namespace local-port:remote-port
```

Replace `your-service-name` with the name of your Kubernetes Service, `your-namespace` with the namespace where your application is deployed, `local-port` with the local port on your machine, and `remote-port` with the port your application is listening on within the cluster.
<br>
<br>


